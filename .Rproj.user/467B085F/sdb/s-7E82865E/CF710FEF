{
    "collab_server" : "",
    "contents" : "mciModel.kl <- function(x,...){\n  varNames = names(dimnames(x))\n  misTemp = list(varNames) #temp Maximal Ind Set\n  misFinal = NULL  #Final Maximal Ind Set\n  curMod.terms = varNames #initialize current interaction terms to main effects \n  curMod.kl = NULL #current model fit\n  #alpha = 0.05\n  #sat.aic = comput.sat.AIC(x)\n  #curr.kl = compute.kl(x)\n  while(length(misTemp)>0){\n    mciSet = unlist(misTemp[1])\n    #mc.aic = mci.aic(x,mciSet)\n    if(length(mciSet)< 2 ){\n      #singleton \n      misFinal = union(misFinal,misTemp[1])\n      misTemp = misTemp[-1]\n    }\n    else{\n      \n      \n      \n      \n      {\n        if(is.null(curMod.kl)){\n          #curMod.kl = compute.indp.kl(x) #compute inependence model kl\n          mc.kl = compute.indp.kl(x)\n          #curMod.df = mc$df\n          curMod.kl = 0\n        }\n        else{\n          mc.kl = mci.kl(x,mciSet)\n        }\n        \n        if(mc.kl <= curMod.kl){\n        #if(mc$p.value >= alpha){\n          ## Mutual conditional relation holds among MIS, remove it from tempMIS\n          misFinal = union(misFinal,misTemp[1])\n          misTemp = misTemp[-1]\n        }\n        else{\n          edgeSet = .vec2pairs(unlist(misTemp[1]))\n          #devDiff = rep(0,length(edgeSet))\n          #df = rep(0,length(edgeSet))\n          kl =  rep(0,length(edgeSet))\n          for(i in 1:length(edgeSet)){\n            edge = unlist(edgeSet[i])\n            interact = paste0(edge[1],\"*\",edge[2])\n            tempTerms = union(curMod.terms,interact)\n            \n            #fm = as.formula(paste(\"~\",paste(tempTerms,collapse=\"+\")))        \n            #lm = loglm(fm,x)\n            maxCls = .terms2MaxCliques(tempTerms)\n            lm = loglin(x,maxCls,fit=TRUE,print=FALSE)\n            \n            kl[i] = compute.kl(x,lm$fit)\n            \n            #devDiff[i] = curMod.lrt- lm$lrt #deviance difference\n            #df[i] =  lm$df\n          }      \n          indx = which.min(kl)\n          \n          curMod.kl = kl[indx]\n          #curMod.df = df[i]\n          edge = unlist(edgeSet[indx])\n          misTemp = .add.term(misTemp,edge)\n          \n          interact = paste0(edge[1],\"*\",edge[2])\n          curMod.terms = union(curMod.terms,interact)          \n        }\n      }\n      ##fixme \n    }\n    \n  }\n  model =  .terms2MaxCliques(curMod.terms)\n  adMat = .terms2adjMat(curMod.terms)\n  kl = curMod.kl\n  \n  ans <- list(model=model, statistic = \"AIC\", kl = kl, adjMat = adMat)\n  class(ans) <- \"mciModel\"\n  ans\n}\n\n## ########################################################\n##\n## Testing for mutual condional independence in a contingency table\n## test based on either deviance or Pearsons chi square\n## <x>  : table\n## <miset>: NULL, a vector of factors to be tested for \n##          MCI(mutual conditional independence)\n## <cfset>: NULL, a vector of conditioning factors\n## <statistic>: DEV, deviance or chi-squae based test\n## ########################################################\nmci.kl <- function(x, miset=NULL)\n{\n  set1 <- names(dimnames(x))\n  cfset = setdiff(set1,miset)\n  \n  if(length(cfset) == 0){\n    cfset = NULL\n  }  \n  \n  if (is.null(cfset)){\n    dn = dim(x)\n    \n    tab1 =  tableMargin(x, miset[1])\n    dof = dn[1]\n    maxCls = lapply(set1,function(ll){ll})#independence model\n    \n    for(i in 2:length(miset)){\n      tab2 <-   tableMargin(x, miset[i])\n      tab1 = tableOp(tab1, tab2)\n      dof = dof+dn[i]\n    }\n    \n    fit.table <- tablePerm(tab1, miset)/(sum(x))^(length(miset)-1)\n    dof = prod(dn) - dof + (length(miset)-1) #compute DOF\n  } \n  else{\n    vn <- names(dimnames(x))\n    \n    margin1 = tableMargin(x, miset)\n    margin2 = tableMargin(x, cfset)\n    dm1 = dim(margin1)\n    dm2 = dim(margin2)\n    \n    marTab1 =  tableMargin(x, c(miset[1],cfset))\n    \n    cf.dof = prod(dm2)\n    mi.dof = dm1[1]*cf.dof\n    \n    maxCls = lapply(miset, function(ll) {\n      union(ll, cfset) })\n    \n    for(i in 2:length(miset)){\n      marTab2 <-   tableMargin(x, c(miset[i],cfset))    \n      marTab1 = tableOp(marTab1, marTab2)      \n      marTab1 = tableOp(marTab1, margin2,\"/\")\n      mi.dof = mi.dof+(dm1[i]*cf.dof)\n    }\n    \n    fit.table <- tablePerm(marTab1, vn)\n    cf.dof = cf.dof*(length(miset)-1)\n    dof = prod(dim(x)) - mi.dof+cf.dof #compute DOF\n    \n  }\n  \n  ans = compute.kl(x,fit.table)\n  \n  ans\n}\n",
    "created" : 1497068187758.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2439163420",
    "id" : "CF710FEF",
    "lastKnownWriteTime" : 1434100018,
    "last_content_update" : 1434100018,
    "path" : "C:/Niharika/RPrograms/gMCI/R/klDivModel.R",
    "project_path" : "R/klDivModel.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}