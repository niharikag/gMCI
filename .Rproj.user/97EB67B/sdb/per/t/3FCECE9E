{
    "contents" : "## ########################################################\n##\n## Forward Model Selection based mutual condional independence \n## test based on deviance \n## <x>  : table\n## ########################################################\nmciModel_table <- function(x, statistic, ...)\n{\n  if(statistic == \"DEV\"){\n    ans <- .mciModel.dev(x, ...)\n  }\n  else{\n    ans <- .mciModel.aic(x, ...)\n  }\n  \n  return(ans)\n}\n\n.mciModel.dev <- function(x, ...){\n  varNames = names(dimnames(x))\n  misTemp = list(varNames) #temp Maximal Ind Set\n  misFinal = NULL  #Final Maximal Ind Set\n  alpha = 0.05\n  curMod.terms = varNames #initialize current interaction terms to main effects \n  curMod.lrt = NULL #current model fit\n  \n  while(length(misTemp)>0){\n    mciSet = unlist(misTemp[1])\n    mc = mciTest(x,mciSet)\n    \n    if(is.null(curMod.lrt)){\n      curMod.lrt = mc$statistic\n      curMod.df = mc$df\n    }\n    \n    if(mc$p.value >= alpha){\n      ## Mutual conditional relation holds among MIS, remove it from tempMIS\n      misFinal = union(misFinal,misTemp[1])\n      misTemp = misTemp[-1]\n    }\n    else{\n      edgeSet = .vec2pairs(unlist(misTemp[1]))\n      devDiff = rep(0,length(edgeSet))\n      df = rep(0,length(edgeSet))\n      lrt =  rep(0,length(edgeSet))\n      for(i in 1:length(edgeSet)){\n        edge = unlist(edgeSet[i])\n        interact = paste0(edge[1],\"*\",edge[2])\n        tempTerms = union(curMod.terms,interact)\n        \n        #fm = as.formula(paste(\"~\",paste(tempTerms,collapse=\"+\")))        \n        #lm = loglm(fm,x)\n        maxCls = .terms2MaxCliques(tempTerms)\n        lm = loglin(x, maxCls, print=FALSE)\n        lrt[i] =  lm$lrt \n        devDiff[i] = curMod.lrt- lm$lrt #deviance difference\n        df[i] =  lm$df\n      }      \n      indx = which.max(devDiff)\n      p.value = 1-pchisq(devDiff[indx],(curMod.df - df[indx]) )\n      if(p.value < alpha){\n        curMod.lrt = lrt[indx]\n        curMod.df = df[i]\n        edge = unlist(edgeSet[indx])\n        misTemp = .add.term(misTemp,edge)\n        \n        interact = paste0(edge[1],\"*\",edge[2])\n        curMod.terms = union(curMod.terms,interact)\n      }\n      else{\n        misFinal = union(misFinal,misTemp[1])\n        misTemp = misTemp[-1]\n      }            \n    }\n    ##fixme \n    \n  }\n  #model = (paste(\"~\",paste(curMod.terms,collapse=\"+\")))\n  model =  .terms2MaxCliques(curMod.terms)\n  adMat = .terms2adjMat(curMod.terms)\n  p.value = 1-pchisq(curMod.lrt,curMod.df)\n  \n  ans <- list(model=model, statistic = \"DEV\", dev=curMod.lrt, df=curMod.df, \n              p.value = p.value, method=\"CHISQ\",adjMat = adMat)\n  class(ans) <- \"mciModel\"\n  ans\n  \n}\n\n.mciModel.aic <- function(x,...){\n  varNames = names(dimnames(x))\n  misTemp = list(varNames) #temp Maximal Ind Set\n  misFinal = NULL  #Final Maximal Ind Set\n  curMod.terms = varNames #initialize current interaction terms to main effects \n  curMod.aic = NULL #current model fit\n  alpha = 0.05\n  sat.aic = comput.sat.AIC(x)\n  \n  while(length(misTemp)>0){\n    mciSet = unlist(misTemp[1])\n    #mc.aic = mci.aic(x,mciSet)\n    mc = mciTest(x,mciSet)\n    \n    if(is.null(curMod.aic)){\n      curMod.aic = sat.aic\n      #curMod.df = mc$df\n    }\n    \n    #if(mc.aic <= curMod.aic){\n    if(mc$p.value >= alpha){\n      ## Mutual conditional relation holds among MIS, remove it from tempMIS\n      misFinal = union(misFinal,misTemp[1])\n      misTemp = misTemp[-1]\n    }\n    else if(length(unlist(misTemp[1]))<2){\n      #singleton \n      misFinal = union(misFinal,misTemp[1])\n      misTemp = misTemp[-1]\n    }\n    else{\n      edgeSet = .vec2pairs(unlist(misTemp[1]))\n      #devDiff = rep(0,length(edgeSet))\n      #df = rep(0,length(edgeSet))\n      aic =  rep(0,length(edgeSet))\n      for(i in 1:length(edgeSet)){\n        edge = unlist(edgeSet[i])\n        interact = paste0(edge[1],\"*\",edge[2])\n        tempTerms = union(curMod.terms,interact)\n        \n        #fm = as.formula(paste(\"~\",paste(tempTerms,collapse=\"+\")))        \n        #lm = loglm(fm,x)\n        maxCls = .terms2MaxCliques(tempTerms)\n        lm = loglin(x,maxCls,fit=TRUE,print=FALSE)\n        \n        aicInfo = computAIC(x,maxCls,lm$fit)\n        aic[i] =  aicInfo$aic\n        #devDiff[i] = curMod.lrt- lm$lrt #deviance difference\n        #df[i] =  lm$df\n      }      \n      indx = which.min(aic)\n      \n      curMod.aic = aic[indx]\n      #curMod.df = df[i]\n      edge = unlist(edgeSet[indx])\n      misTemp = .add.term(misTemp,edge)\n      \n      interact = paste0(edge[1],\"*\",edge[2])\n      curMod.terms = union(curMod.terms,interact)          \n    }\n    ##fixme \n    \n  }\n  model =  .terms2MaxCliques(curMod.terms)\n  adMat = .terms2adjMat(curMod.terms)\n  aic = curMod.aic\n  \n  ans <- list(model=model, statistic = \"AIC\", aic = aic, adjMat = adMat)\n  class(ans) <- \"mciModel\"\n  ans\n}\n\n## ########################################################\n##\n## Testing for mutual condional independence in a contingency table\n## test based on either deviance or Pearsons chi square\n## <x>  : table\n## <miset>: NULL, a vector of factors to be tested for \n##          MCI(mutual conditional independence)\n## <cfset>: NULL, a vector of conditioning factors\n## <statistic>: DEV, deviance or chi-squae based test\n## ########################################################\nmci.aic <- function(x, miset=NULL)\n{\n  set1 <- names(dimnames(x))\n  cfset = setdiff(set1,miset)\n       \n  if(length(cfset) == 0){\n    cfset = NULL\n  }  \n  \n  if (is.null(cfset)){\n    dn = dim(x)\n    \n    tab1 =  tableMargin(x, miset[1])\n    dof = dn[1]\n    maxCls = lapply(set1,function(ll){ll})#independence model\n    \n    for(i in 2:length(miset)){\n      tab2 <-   tableMargin(x, miset[i])\n      tab1 = tableOp(tab1, tab2)\n      dof = dof+dn[i]\n    }\n    \n    fit.table <- tablePerm(tab1, miset)/(sum(x))^(length(miset)-1)\n    dof = prod(dn) - dof + (length(miset)-1) #compute DOF\n  } \n  else{\n    vn <- names(dimnames(x))\n    \n    margin1 = tableMargin(x, miset)\n    margin2 = tableMargin(x, cfset)\n    dm1 = dim(margin1)\n    dm2 = dim(margin2)\n    \n    marTab1 =  tableMargin(x, c(miset[1],cfset))\n    \n    cf.dof = prod(dm2)\n    mi.dof = dm1[1]*cf.dof\n    \n    maxCls = lapply(miset, function(ll) {\n      union(ll, cfset) })\n    \n    for(i in 2:length(miset)){\n      marTab2 <-   tableMargin(x, c(miset[i],cfset))    \n      marTab1 = tableOp(marTab1, marTab2)      \n      marTab1 = tableOp(marTab1, margin2,\"/\")\n      mi.dof = mi.dof+(dm1[i]*cf.dof)\n    }\n    \n    fit.table <- tablePerm(marTab1, vn)\n    cf.dof = cf.dof*(length(miset)-1)\n    dof = prod(dim(x)) - mi.dof+cf.dof #compute DOF\n    \n  }\n  \n  ans = computAIC(x,maxCls,fit.table)\n \n  ans$aic\n}\n\n",
    "created" : 1433504653172.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3202379155",
    "id" : "3FCECE9E",
    "lastKnownWriteTime" : 1433740552,
    "path" : "E:/RPrograms/gMCI/gMCI/R/mciModel_table.R",
    "project_path" : "R/mciModel_table.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}